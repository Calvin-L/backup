package cal.bkup.impls;

import cal.bkup.Util;
import cal.bkup.types.BackupReport;
import cal.bkup.types.IndexFormat;
import cal.bkup.types.Sha256AndSize;
import cal.prim.MalformedDataException;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Test
public class VersionedIndexFormatTests {

  @Test
  public void testVersionNumberSerialization() throws IOException, MalformedDataException {

    byte[] bytes = new byte[4];
    for (int i : new int[] { Integer.MIN_VALUE, -256, -255, -1, 0, 1, 2, 10, 255, 256, Integer.MAX_VALUE }) {
      VersionedIndexFormat.serializeBigEndianInt(i, bytes, 0);
      Assert.assertEquals(VersionedIndexFormat.readBigEndianInt(new ByteArrayInputStream(bytes)), i);
    }

  }

  @Test
  public void testMultiVersionSerialization() throws IOException, MalformedDataException {

    byte[] blob = new byte[] { (byte)0x11 };

    BackupIndex index = new BackupIndex();
    index.addBackedUpBlob(
            new Sha256AndSize(Util.sha256(new ByteArrayInputStream(blob)), blob.length),
            new BackupReport("foo", 10, "backupname"));

    IndexFormat magicalFutureFormat = new IndexFormat() {
      @Override
      public BackupIndex load(InputStream data) {
        return index;
      }

      @Override
      public InputStream serialize(BackupIndex index) {
        return new ByteArrayInputStream(new byte[] { 1, 2, 3, 4 });
      }
    };

    IndexFormat[] versions = new IndexFormat[] {
            new JsonIndexFormatV01(),
            magicalFutureFormat
    };

    List<IndexFormat> versionsToTest = new ArrayList<>();
    versionsToTest.add(versions[0]);
    for (int i = 1; i < versions.length; ++i) {
      versionsToTest.add(new VersionedIndexFormat(Arrays.copyOfRange(versions, 0, i)));
    }

    // Each format must be able to read indexes generated by itself and each earlier format.
    for (int fmtA = 0; fmtA < versionsToTest.size(); ++fmtA) {
      for (int fmtB = fmtA; fmtB < versionsToTest.size(); ++fmtB) {
        System.out.println("Checking migration from " + fmtA + " to " + fmtB);
        byte[] serialized = Util.read(versionsToTest.get(fmtA).serialize(index));
        Assert.assertEquals(versionsToTest.get(fmtB).load(new ByteArrayInputStream(serialized)), index);
      }
    }

  }

}
