package cal.bkup.impls;

import cal.bkup.Util;
import cal.bkup.types.BackupReport;
import cal.bkup.types.IndexFormat;
import cal.bkup.types.Sha256AndSize;
import cal.bkup.types.SystemId;
import cal.prim.MalformedDataException;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Test
@SuppressWarnings("required.method.not.called")
public class VersionedIndexFormatTests {

  @Test
  public void testVersionNumberSerialization() throws IOException, MalformedDataException {

    byte[] bytes = new byte[4];
    for (int i : new int[] { Integer.MIN_VALUE, -256, -255, -1, 0, 1, 2, 10, 255, 256, Integer.MAX_VALUE }) {
      VersionedIndexFormat.serializeBigEndianInt(i, bytes, 0);
      Assert.assertEquals(VersionedIndexFormat.readBigEndianInt(new ByteArrayInputStream(bytes)), i);
    }

  }

  static BackupIndex createTestIndex() {

    byte[] blob = new byte[] { (byte)0x11 };

    BackupIndex index = new BackupIndex();
    Sha256AndSize summary = null;
    try {
      summary = new Sha256AndSize(Util.sha256(new ByteArrayInputStream(blob)), blob.length);
    } catch (IOException e) {
      throw new RuntimeException("insanity: reading from a byte array produced an IOException", e);
    }
    index.addBackedUpBlob(
            summary,
            new BackupReport("foo", 0, 10, "backupname"));

    var system = new SystemId("test-system");
    var backup = index.startBackup(system, Instant.now());
    index.appendRevision(system, backup, Paths.get("/tmp/foo"), Instant.now(), summary);
    index.finishBackup(system, backup, Instant.now());

    return index;
  }

  @Test
  public void testMultiVersionSerialization() throws IOException, MalformedDataException {
    BackupIndex index = createTestIndex();

    IndexFormat magicalFutureFormat = new IndexFormat() {
      @Override
      public BackupIndex load(InputStream data) {
        return index;
      }

      @Override
      public InputStream serialize(BackupIndex index) {
        return new ByteArrayInputStream(new byte[] { 1, 2, 3, 4 });
      }
    };

    IndexFormat[] versions = new IndexFormat[] {
            new JsonIndexFormatV01(),
            new JsonIndexFormatV02(),
            magicalFutureFormat
    };

    List<IndexFormat> versionsToTest = new ArrayList<>();
    versionsToTest.add(versions[0]);
    for (int i = 1; i < versions.length; ++i) {
      @SuppressWarnings("assignment") // i < versions.length, so no nulls get added to the array
      @NonNull IndexFormat[] a = Arrays.copyOfRange(versions, 0, i);

      versionsToTest.add(new VersionedIndexFormat(a));
    }

    // Each format must be able to read indexes generated by itself and each earlier format.
    for (int fmtA = 0; fmtA < versionsToTest.size(); ++fmtA) {
      for (int fmtB = fmtA; fmtB < versionsToTest.size(); ++fmtB) {
        System.out.println("Checking migration from " + fmtA + " to " + fmtB);
        byte[] serialized = Util.read(versionsToTest.get(fmtA).serialize(index));

        // NOTE: This test ensures that version B reads the index in the same way as version A.
        // It does NOT ensure that they both read the correct index.  This is because some old
        // formats drop information from the index during serialization, so it actually isn't
        // true that they produce the correct result.  Only the latest format is expected to be
        // able to flawlessly reproduce the index.
        BackupIndex expected = versionsToTest.get(fmtA).load(new ByteArrayInputStream(serialized));
        Assert.assertEquals(versionsToTest.get(fmtB).load(new ByteArrayInputStream(serialized)), expected);
      }
    }

  }

}
